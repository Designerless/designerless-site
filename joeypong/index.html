<!doctype html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Joey Pong</title>

<meta name="viewport"
content="width=device-width, height=device-height, initial-scale=1.0, user-scalable=no">

<style>
html, body {
  margin: 0;
  padding: 0;
  height: 100%;
  background: #000;
  overflow: hidden;
  font-family: system-ui, sans-serif;
  overscroll-behavior: none;
  touch-action: none;
}

canvas { display: block; }

.menu, .overlay {
  position: absolute;
  inset: 0;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  gap: 18px;
  background: rgba(0,0,0,0.9);
  z-index: 10;
}

#rotateNotice {
  display: none;
  position: fixed;
  inset: 0;
  background: black;
  color: white;
  z-index: 999;
  align-items: center;
  justify-content: center;
  font-size: 28px;
  text-align: center;
}

h1 {
  color: white;
  font-size: clamp(48px, 8vw, 96px);
  margin: 0;
}

button {
  font-size: 22px;
  padding: 14px 28px;
  border-radius: 12px;
  border: none;
  cursor: pointer;
  background: white;
  color: black;
  min-width: 260px;
}
</style>
</head>
<body>

<div id="rotateNotice">Rotate your device to play</div>

<div class="menu" id="menu">
  <h1>JOEY PONG</h1>
  <button onclick="startCPU('easy')">1 PLAYER – EASY</button>
  <button onclick="startCPU('hard')">1 PLAYER – HARD</button>
  <button onclick="startPVP()">2 PLAYER</button>
</div>

<div class="overlay" id="gameOver" style="display:none">
  <h1 id="winnerText"></h1>
  <button onclick="backToMenu()">BACK TO MENU</button>
</div>

<canvas id="game"></canvas>

<script>
/* ================= SETUP ================= */
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

const menu = document.getElementById("menu");
const gameOver = document.getElementById("gameOver");
const winnerText = document.getElementById("winnerText");
const rotateNotice = document.getElementById("rotateNotice");

const ballImg = new Image();
ballImg.src = "JoeyPongBall.png";

const paddleImg = new Image();
paddleImg.src = "paddle.png";

let W, H;
function resize() {
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
  checkOrientation();
}
window.addEventListener("resize", resize);
window.addEventListener("orientationchange", resize);
resize();

/* ================= MOBILE ORIENTATION ================= */
function checkOrientation() {
  const isMobile = /Mobi|Android|iPhone|iPad/i.test(navigator.userAgent);
  const isPortrait = window.innerHeight > window.innerWidth;

  if (isMobile && isPortrait) {
    rotateNotice.style.display = "flex";
    playing = false;
  } else {
    rotateNotice.style.display = "none";
  }
}

/* ================= AUDIO ================= */
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
function beep(freq, dur = 0.05) {
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = "square";
  o.frequency.value = freq + Math.random() * 60;
  g.gain.value = 0.08;
  o.connect(g);
  g.connect(audioCtx.destination);
  o.start();
  o.stop(audioCtx.currentTime + dur);
}

/* ================= INPUT ================= */
const keys = {};
window.addEventListener("keydown", e => keys[e.key] = true);
window.addEventListener("keyup", e => keys[e.key] = false);

let touchLeftY = null;
let touchRightY = null;

canvas.addEventListener("touchstart", handleTouch, { passive:false });
canvas.addEventListener("touchmove", handleTouch, { passive:false });
canvas.addEventListener("touchend", () => {
  touchLeftY = null;
  touchRightY = null;
});

function handleTouch(e) {
  e.preventDefault();
  const r = canvas.getBoundingClientRect();
  for (const t of e.touches) {
    const x = t.clientX - r.left;
    const y = t.clientY - r.top;
    if (x < W / 2) touchLeftY = y;
    else touchRightY = y;
  }
}

/* ================= STATE ================= */
let playing = false;
let scoreL = 0;
let scoreR = 0;
const WIN_SCORE = 7;
let mode = "pvp";
let difficulty = "easy";

/* ================= CPU ================= */
const CPU = {
  easy: { speed: 0.65, reaction: 0.18, error: 0.18 },
  hard: { speed: 0.9, reaction: 0.07, error: 0.06 }
};

/* ================= OBJECTS ================= */
const paddle = {
  w: 32,
  h: () => H * 0.2,
  speed: () => H * 0.9
};

const p1 = {};
const p2 = {};

const ball = {
  x: 0,
  y: 0,
  vx: 0,
  vy: 0,
  speed: 0,
  wallCooldown: 0,
  r: () => Math.min(W, H) * 0.07
};

/* ================= FLOW ================= */
function reset() {
  p1.x = W * 0.04;
  p2.x = W * 0.96 - paddle.w;
  p1.y = p2.y = H / 2 - paddle.h() / 2;
  ball.x = W / 2;
  ball.y = H / 2;
  ball.speed = Math.min(W, H) * 0.75;
  ball.wallCooldown = 0;
}

function serve() {
  const dir = Math.random() < 0.5 ? -1 : 1;
  const a = Math.random() * 0.4 - 0.2;
  ball.vx = Math.cos(a) * ball.speed * dir;
  ball.vy = Math.sin(a) * ball.speed;
}

function startCPU(diff) {
  mode = "cpu";
  difficulty = diff;
  startGame();
}
function startPVP() {
  mode = "pvp";
  startGame();
}
function startGame() {
  menu.style.display = "none";
  gameOver.style.display = "none";
  scoreL = scoreR = 0;
  reset();
  serve();
  playing = true;
}
function backToMenu() {
  playing = false;
  menu.style.display = "flex";
}

/* ================= UPDATE ================= */
function update(dt) {
  ball.wallCooldown -= dt;

  if (keys["w"]) p1.y -= paddle.speed() * dt;
  if (keys["s"]) p1.y += paddle.speed() * dt;
  if (touchLeftY !== null) p1.y = touchLeftY - paddle.h() / 2;

  if (mode === "pvp") {
    if (keys["ArrowUp"]) p2.y -= paddle.speed() * dt;
    if (keys["ArrowDown"]) p2.y += paddle.speed() * dt;
    if (touchRightY !== null) p2.y = touchRightY - paddle.h() / 2;
  } else if (touchRightY === null) {
    const cpu = CPU[difficulty];
    p2.y += Math.sign(ball.y - paddle.h()/2 - p2.y) *
            paddle.speed() * cpu.speed * dt;
  }

  p1.y = Math.max(0, Math.min(H - paddle.h(), p1.y));
  p2.y = Math.max(0, Math.min(H - paddle.h(), p2.y));

  ball.x += ball.vx * dt;
  ball.y += ball.vy * dt;

  // TOP wall
  if (ball.y - ball.r() < 0) {
    ball.y = ball.r();
    ball.vy = Math.abs(ball.vy);
    if (ball.wallCooldown <= 0) {
      beep(300);
      ball.wallCooldown = 0.08;
    }
  }

  // BOTTOM wall
  if (ball.y + ball.r() > H) {
    ball.y = H - ball.r();
    ball.vy = -Math.abs(ball.vy);
    if (ball.wallCooldown <= 0) {
      beep(300);
      ball.wallCooldown = 0.08;
    }
  }

  function hit(p, dir) {
    if (
      ball.x + ball.r() > p.x &&
      ball.x - ball.r() < p.x + paddle.w &&
      ball.y + ball.r() > p.y &&
      ball.y - ball.r() < p.y + paddle.h()
    ) {
      ball.speed *= 1.03;
      ball.speed += 6;
      const rel = (ball.y - (p.y + paddle.h()/2)) / (paddle.h()/2);
      const a = Math.max(-Math.PI/4, Math.min(Math.PI/4, rel * Math.PI/4));
      ball.vx = Math.cos(a) * ball.speed * dir;
      ball.vy = Math.sin(a) * ball.speed;
      beep(600);
    }
  }

  hit(p1, 1);
  hit(p2, -1);

  if (ball.x < 0) { scoreR++; score(); }
  if (ball.x > W) { scoreL++; score(); }
}

function score() {
  if (scoreL >= WIN_SCORE || scoreR >= WIN_SCORE) {
    playing = false;
    winnerText.textContent =
      mode === "cpu"
        ? (scoreL ? "PLAYER WINS" : "COMPUTER WINS")
        : (scoreL ? "PLAYER 1 WINS" : "PLAYER 2 WINS");
    gameOver.style.display = "flex";
  } else {
    reset();
    serve();
  }
}

/* ================= DRAW ================= */
function draw() {
  ctx.clearRect(0, 0, W, H);

  ctx.fillStyle = "#fff";
  for (let y = 0; y < H; y += 40)
    ctx.fillRect(W/2 - 2, y, 4, 24);

  ctx.shadowColor = "#fff";
  ctx.shadowBlur = Math.min(ball.speed * 0.05, 40);
  const r = ball.r();
  ctx.drawImage(ballImg, ball.x - r, ball.y - r, r*2, r*2);
  ctx.shadowBlur = 0;

  ctx.drawImage(paddleImg, p1.x, p1.y, paddle.w, paddle.h());
  ctx.save();
  ctx.translate(p2.x + paddle.w, p2.y);
  ctx.scale(-1, 1);
  ctx.drawImage(paddleImg, 0, 0, paddle.w, paddle.h());
  ctx.restore();

  ctx.font = `bold ${Math.min(W, H) * 0.12}px system-ui`;
  ctx.fillStyle = "#fff";
  ctx.textAlign = "center";
  ctx.textBaseline = "top";

  const scoreY = Math.max(20, H * 0.04);
  ctx.fillText(scoreL, W * 0.25, scoreY);
  ctx.fillText(scoreR, W * 0.75, scoreY);
}

/* ================= LOOP ================= */
let last = performance.now();
function loop(t) {
  const dt = Math.min(0.033, (t - last) / 1000);
  last = t;
  if (playing) update(dt), draw();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body>
</html>
